% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/initialize.R
\name{initialize_nlcm_doubletree}
\alias{initialize_nlcm_doubletree}
\title{Initialize the variational Bayesian algorithm for nested latent class models
with double-tree structured shrinkage}
\usage{
initialize_nlcm_doubletree(
  Y,
  A,
  leaf_ids_units,
  leaf_ids,
  leaf_ids_nodes,
  ancestors,
  v_units,
  h_pau,
  levels,
  vi_params,
  hyperparams,
  hyper_fixed,
  random_init,
  random_init_vals
)
}
\arguments{
\item{Y}{matrix of binary observations; preprocessed data from
\code{\link[=design_doubletree]{design_doubletree()}} stored in \code{resB$Y}. \code{NA} missing data is allowed,
which in the nested latent class model will be treated as missing at random.}

\item{A}{a list of two square binary matrices: the first is \code{p1} by \code{p1},
with \code{1}s in each row indicating the ancestors (the node in that row included)
in the first tree (cause tree). The second element is \code{p2} by \code{p2},
the counterpart for the second tree (domain tree.) The row names of
each square matrix are the orders of the trees.}

\item{leaf_ids_units}{unit ids nested in each leaf node;
a list of two elements (for tree1 and tree2); each element is again a list -
each of its element is associated with a leaf in a tree and contains the subject ids in that leaf node.}

\item{leaf_ids}{a list of length two; each element is a vector of character strings
indicating the leaf label an observation is coming from. For the first element,
there might be missing values, including unobserved leaf label in tree1.}

\item{leaf_ids_nodes}{leaf descendants; a list of two elements (for tree1 and tree2);
for each element, the leaf descendants for each internal or leaf nodes (a list)}

\item{ancestors}{a list of two elements (for tree1 and tree2);
Each element is a list, with each element containing numeric vector
of ancestor nodes - the length is equal to the number of leaves in a tree.}

\item{v_units}{a list of two elements (for tree1 and tree2) - both are of length \code{N};
each element is a vector of integers indicating the leaf ids. In the first element, there might
be missing entries, indicating the missing leaf label in tree1.}

\item{h_pau}{edge weights; a list of two elements (for tree1 and tree2);
a numeric vector (length = #nodes) the edge length between a node and its parent node.
The root node has no parent, we set the edge length toward root node to \code{1}.}

\item{levels}{a list of two elements (for tree1 and tree2);
For each element, a numeric vector of integers from \code{1} to \code{Fg1} for the first tree
(or \code{Fg2} for the second tree), indicating for each node which set of hyperparameters
to use. The levels are pre-specfied, not estimated. We recommend at least
five nodes in any level for learning the slab variance parameters.}

\item{vi_params}{the list of variational parameters.}

\item{hyperparams}{the list of hyperparameters}

\item{hyper_fixed}{a list of fixed hyperparameters: the number of classes \code{K};
\verb{(a1,b1)} and \verb{(a2,b2)} are the Beta hyperparameters
for selecting slab components; \code{dmat} the hyperparameters in the Dirichlet
distributions for each domain (i.e., each leaf of tree2.)}

\item{random_init}{logical; \code{TRUE} for adding additional variability to the initial values;
This is a must if the algorithm needs multiple random starts to choose
the best converged values. Currently the \code{logit(0.5)} of response probability may produce
zero, The sd_frac is a fraction of the logit value, which may not be producing any additional randomness.}

\item{random_init_vals}{NB: fill out specific elements; this is to be done.}
}
\value{
a list of two elements:\code{vi_params},\code{hyperparams} with initial values for the
nested latent class model with double tree shrinkage. \code{target_id} and \code{scenario} are
both added (use \code{?doubletree} to see meanings of scenarios).
}
\description{
NB: 1) does this work with missing CODs in all domains (not just the target domain);
2) does this work with partially-known labels in the target domain (not all are
missing)
Organize intermediate variables,
\enumerate{
\item target_id.
\item who are in the target domain
\item who are the people from cause c and domain g
\item check the mapping from integers to leaves; same for all the nodes
}
}
